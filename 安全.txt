

================================================ 安全 ====================================================

===== 跨站攻击===================================

==== 跨站GET攻击=================================

在博客等其他网站上挂上向其他网站发出危险请求的链接，图像。这些请求可能会利用目标网站存储在用户浏览器中的cookie，使请求通过验证。

**解决方法**
改变资源状态的动作应该使用POST请求

==== 跨站请求攻击post remote csrf =======================
黑客制作向目标网站发出POST请求的表单，利用目标网站存储在用户浏览器中的cookie来使请求通过验证。

**解决方法**
(1) 在application_controller.rb 中增加行：
	''protect_from_forgery	#only non-GET, HTML/JavaScript requests are checked.''
这会检查所有non-GET请求和javascript请求

(2) 另一方面，RAILS 表单使用 form_for 等helper，这些helper会自动添加一个包含secret token 的hidden field，只有这些信息在服务器上完成认证以后，请求才能执行。

<form accept-charset="UTF-8" action="/users/1" method="post">
<input type="hidden"
       value="67250ab105eb5ad10851c00a5621854a23af5489"
       name="authenticity_token"/>
</form>

(3) 最后在layout 文件的header区域中添加：
	''<%= csrf_meta_tags %>''


CSRF 利用的 cookies 验证进行未授权访问，不用 cookies 作为验证就没问题

CSRF是跨站攻击，只对普通的「网站」（当然也包括网站应用）有效。如果是不走网页访问，而是直接调用API的话，CSRF本身就是无效的。CSRF不能防止第三方直接调用接口。
===== 利用上传和下载文件 =====

 __Make sure file uploads don't overwrite important files, and process media files asynchronously.__

==== 防止用户提交的文件覆盖系统敏感文件 ====
**攻击方法**
例如文件名为 "../../etc/passwd" 导致上传后覆盖系统敏感文件。

**解决方案**

(1) 对文件名消毒，只允许包含指定集合的字符。一般来说，文件上传插件已经做了这部分工作

(2) 给予网页服务器如apache以较低的权限，使其无法修改系统文件

==== 异步后台处理较耗时的项目 ====
**攻击方法**
如果系统处理文件需要比较长的时间，而且不是以后台异步方式处理，这会加重服务器的负担。攻击者可以大量上传的方式使服务器瘫痪

解决方案
对需要较长处理时间的操作，以异步后台的方式处理。


==== 不要在public 一级目录中存储用户提交的文件 ====
在apache documentRoot 目录(一般是Rails 的 public 文件夹) 下的一些后缀的文件会在请求时执行，例如php, cgi文件。

解决方案
不要在用public 目录直接存储用户提交的文件，如果要在这里存储文件，也要放在其子文件夹下。

==== 不要允许用户指定要下载的文件名 ====
如果文件名由用户提供，那么黑客就能够下载任意文件。

**解决方案**
如果真的需要用户提供用户名，则检查该名称，是否和预期的目录相同

在数据库中存储文件名，文件实际的名称则由此数据库条目计算得到。这样只有当用户输入的文件名能够匹配数据库中记录的文件名时，才开始传送对应文件。

=================App===================
1、APP和服务器接口先约定好一个密钥；
2、登录之后服务器接口返回一个Token；
3、APP在之后需要验证的请求中都要加上这个Token，以及进行签名。

签名方式其实跟很多支付接口一样，把所有的参数加上约定好的密钥进行Sha1或者MD5加密，得到签名字符串，传到服务器接口后再进行验证。

安全问题：
我们会在参数里边加一个timestamp字段，获取当前的时间戳，类似：1485159939.454，一并放进参数列表并签名。
服务器接口会检测时间戳不能误差超出2分钟，然后会在REDIS里边记录这个时间戳（2分钟后自动删除），用来判断重复请求。
这样就算不是https，被抓包了，重复请求就会报错
