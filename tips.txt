1:自动加载和重新加载常量中主要内容：
    Kernel#require 加载一次 #所以在生产环境下 如果不重新启动服务，修改内容不生效
    kernel#load    加载多次 #所以在开发环境下 更改后无需重新启动服务即可生效，开发环境下更为友好
    autoload_paths 默认包含：

    A： app 目录中的全部子目录都自动纳入 autoload_paths
    B： 应用和引擎中名为 app/*/concerns 的二级目录。
    C： test/mailers/previews 目录。
    此外，可以在application.rb中配置autoload_paths目录，在各个环境的配置文件中不能配置 config.autoload_paths
    autoload_paths 在初始化过程中计算并缓存
    自动加载不要求必须是类或者模块，也可以是普通常量
 2： 常量的重新加载 reload! 会检测以下一个文件变化
      config/routes.rb

      Locales

      autoload_paths 中的 Ruby 文件

      db/schema.rb 和 db/structure.sql
      如果这些文件中的内容有变，有个中间件会发现，然后重新加载代码。
  3：require_dependency
     单表继承（Single Table Inheritance，STI）是 Active Record 的一个功能
     作用是在一个数据表中添加具有层次结构的多个模型。
     require_dependency: 有时执行到某部分代码时想确保特定常量是已知的,常用于解决single tale Inheritance手动加载子类
  4： A：在运行时处理页面渲染，可以使用一个符号把布局延后到处理请求时再选择
      layout :layout_choose
      private
        def layout_choose
          @current_user.special? ? "special" : "products"
        end
      还可以使用行间方法，如果使用 Proc其代码块可以访问 controller 实例
      class ProductsController < ApplicationController
        # controller指的是Controller的示例
        layout Proc.new { |controller| controller.request.xhr? ? "popup" : "application" }
      end
      B：根据条件设定布局
       layout "product", except: [:index, :rss]
     C:布局的继承： 专用布局比通用布局优先级高
  5： Can only render or redirect once per action（一个动作只能渲染或重定向一次）
      解决方法 在需要终止渲染后 添加and return
      def show
        @book = Book.find(params[:id])
        if @book.special?
          render action: "special_show"
        end
        render action: "regular_show"
      end
      错误原因： 如果进入if条件内render special_show,此时show方法没有停止运行，继续向下执行渲染regular_show
  6: redirect_to 和 render
     redirect_to  不会立即导致方法返回，停止执行,它们只是设定 HTTP 响应。
     方法中位于其后的语句会继续执行。如果需要停止执行，使用 return 语句终止机制。
     render :action 不会执行目标动作中代码，只是渲染目标中的页面
  7： 布局问题
      引入 app/assets/javascripts/main.js 和 app/assets/javascripts/photos/columns.js 的方式如下：

      <%= javascript_include_tag "main", "/photos/columns" %>
      在布局中，yield 标明一个区域，渲染的视图会插入这里,只有一个 yield，渲染的整个视图都会插入这个区域：
      布局中可以标明多个区域
      <%= yield :head %> <%= yield%>
      视图的主体会插入未命名的 yield 区域
      cotent_for试图主体插入到yield :head
      <% content_for :head do %>
        <title>A simple page</title>
      <% end %>
      如果布局中不同的区域需要不同的内容，例如侧边栏和页脚，就可以使用 content_for 方法。
      content_for 方法还可以在通用布局中引入特定页面使用的 JavaScript 或 CSS 文件
      <div id="content"><%= content_for?(:content) ? yield(:content) : yield %></div>
   8: ssl安全
      基于安全考虑，可能希望某个控制器只能通过 HTTPS 协议访问
      class DinnerController
        force_ssl
      end
     或许你想让整个应用都使用 HTTPS。此时，你可以在环境配置文件中设定 config.force_ssl 选项。
   9:使用前套模版
      <!--如果 content_for :content do 则加载里面内容否则显示为命名的内容-->
      <div id="content"><%= content_for?(:content) ? yield(:content) : yield %></div>
      例子内容： application.html.reb
          <html>
          <head>
            <title><%= @page_title or "Page Title" %></title>
            <%= stylesheet_link_tag "layout" %>
            <style><%= yield :stylesheets %></style>
          </head>
          <body>
          <div id="top_menu">Top menu items here</div>
          <div id="menu">Menu items here</div>
          <div id="content"><%= content_for?(:content) ? yield(:content) : yield %></div>
          </body>
          </html>
      layouts/admin/dashboards.html.erb

        <% content_for :stylesheets do %>
          #top_menu {display: none}
          #right_menu {float: right; background-color: yellow; color: black}
        <% end %>
        <% content_for :content do %>
          <div id="right_menu">Right menu items here</div>
        <% end %>
        <%= render template: "layouts/application" %>
   10: 过滤掉的参数显示:[FILTERED],常用于Rails在log内容线上应用并不用把所有信息都写入日志
    Rails.application.config.filter_parameters += [:password]
   11：  html5
           name=viewport 移动端
           width=device-width,移动端页面的宽度等于设备的宽度
           initial-scale=1.0 页面将是原本尺寸展示
             如果后面是2.0的话，就是是将页面放大两倍
         <meta name="viewport" content="width=device-width, initial-scale=1">
   12: 字符串对象实体化
       ActiveSupport::Dependencies.constantize("Admin::UsersCOntroller")
       平常使用可以直接使用"Admin::UsersController".constantize